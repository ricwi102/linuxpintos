Only in pintos/devices: disk.c~
diff -wur pintos-linux/devices/timer.c pintos/devices/timer.c
--- pintos-linux/devices/timer.c	2015-09-24 19:18:54.001764000 +0200
+++ pintos/devices/timer.c	2016-02-26 14:34:11.000000000 +0100
@@ -35,6 +35,8 @@
 void
 timer_init (void) 
 {
+  list_init(&sleep_list);
+
   /* 8254 input frequency divided by TIMER_FREQ, rounded to
      nearest. */
   uint16_t count = (1193180 + TIMER_FREQ / 2) / TIMER_FREQ;
@@ -96,11 +98,34 @@
 void
 timer_sleep (int64_t ticks) 
 {
-  int64_t start = timer_ticks ();
-
   ASSERT (intr_get_level () == INTR_ON);
+  if(ticks > 0){
+
+    enum intr_level old_level;
+    old_level = intr_disable();
+ 
+    thread_current()->ticks_when_wakeup = timer_ticks() + ticks;
+
+    list_insert_ordered(&sleep_list,&thread_current()->elem, 
+    thread_less_func,NULL);
+
+    thread_block();
+// Prints the wake-up values in the list (to check if it is sorted)
+/*
+    struct list_elem* e;
+    for (e = list_begin(&sleep_list); e != list_end(&sleep_list); e = list_next(e)){
+      struct thread *p_thread = list_entry(e, struct thread, elem);
+      printf("%i", p_thread->ticks_when_wakeup);
+      printf("\n");
+    }
+    printf("%s", "Next loop \n");
+*/
+    intr_set_level(old_level);
+  }
+
+  /*int64_t start = timer_ticks ();
   while (timer_elapsed (start) < ticks) 
-    thread_yield ();
+    thread_yield ();*/
 }
 
 /* Suspends execution for approximately MS milliseconds. */
@@ -136,7 +161,25 @@
 timer_interrupt (struct intr_frame *args UNUSED)
 {
   ticks++;
-  thread_tick ();
+  thread_tick (); // i think this should be at the bottom, (Richard)
+
+  uint8_t i = 0;
+  struct list_elem* e = list_begin(&sleep_list);
+  while(e != list_end(&sleep_list)){
+    struct thread *current_thread = list_entry(e, struct thread, elem);
+    if(current_thread->ticks_when_wakeup <= timer_ticks()){
+      i++;
+      e = list_next(e);
+    }else{ 
+      break;
+    }
+  }
+  for(i; i > 0;--i){
+    e = list_pop_front(&sleep_list);
+    struct thread* t =  list_entry(e,struct thread,elem);
+    thread_unblock(t);
+  }
+
 }
 
 /* Returns true if LOOPS iterations waits for more than one timer
Only in pintos/devices: timer.c~
diff -wur pintos-linux/devices/timer.h pintos/devices/timer.h
--- pintos-linux/devices/timer.h	2015-09-24 19:18:54.002090000 +0200
+++ pintos/devices/timer.h	2016-02-26 14:34:11.000000000 +0100
@@ -7,6 +7,8 @@
 /* Number of timer interrupts per second. */
 #define TIMER_FREQ 100
 
+struct list sleep_list;
+
 void timer_init (void);
 void timer_calibrate (void);
 
Only in pintos/devices: timer.h~
Only in pintos/examples: a.out
Only in pintos/examples: bubsort
Only in pintos/examples: bubsort.d
Only in pintos/examples: bubsort.o
Only in pintos/examples: cat
Only in pintos/examples: cat.d
Only in pintos/examples: cat.o
Only in pintos/examples: child
Only in pintos/examples: child.d
Only in pintos/examples: child.o
Only in pintos/examples: cmp
Only in pintos/examples: cmp.d
Only in pintos/examples: cmp.o
Only in pintos/examples: cp
Only in pintos/examples: cp.d
Only in pintos/examples: cp.o
Only in pintos/examples: create-bad
Only in pintos/examples: create-bad.d
Only in pintos/examples: create-bad.o
Only in pintos/examples: dummy
Only in pintos/examples: dummy.d
Only in pintos/examples: dummy.o
Only in pintos/examples: echo
Only in pintos/examples: echo.d
Only in pintos/examples: echo.o
Only in pintos/examples: halt
Only in pintos/examples: halt.d
Only in pintos/examples: halt.o
Only in pintos/examples: hex-dump
Only in pintos/examples: hex-dump.d
Only in pintos/examples: hex-dump.o
Only in pintos/examples: insult
Only in pintos/examples: insult.d
Only in pintos/examples: insult.o
Only in pintos/examples: lab1test
diff -wur pintos-linux/examples/lab1test.c pintos/examples/lab1test.c
--- pintos-linux/examples/lab1test.c	2015-09-24 19:18:52.001119000 +0200
+++ pintos/examples/lab1test.c	2016-02-26 14:34:11.000000000 +0100
@@ -58,6 +58,8 @@
 	
   write(STDOUT_FILENO, test6, strlen(test6));
   num_bytes_read = read(STDIN_FILENO, sbuf, 10);
+  file[2] = open("test2");
+  write(file[2],sbuf,10);
   if(num_bytes_read != 10){
     printf("Did not read 10 characters from the console.\n");
     halt();
@@ -103,5 +105,5 @@
   }
 
   printf("Test passed\n");
-  halt();
+  exit(0);
 }
Only in pintos/examples: lab1test.c~
Only in pintos/examples: lab1test.d
Only in pintos/examples: lab1test.o
Only in pintos/examples: lab2test
Only in pintos/examples: lab2test.d
Only in pintos/examples: lab2test.o
Only in pintos/examples/lib: arithmetic.d
Only in pintos/examples/lib: arithmetic.o
Only in pintos/examples/lib: debug.d
Only in pintos/examples/lib: debug.o
Only in pintos/examples/lib: random.d
Only in pintos/examples/lib: random.o
Only in pintos/examples/lib: stdio.d
Only in pintos/examples/lib: stdio.o
Only in pintos/examples/lib: stdlib.d
Only in pintos/examples/lib: stdlib.o
Only in pintos/examples/lib: string.d
Only in pintos/examples/lib: string.o
Only in pintos/examples/lib/user: console.d
Only in pintos/examples/lib/user: console.o
Only in pintos/examples/lib/user: debug.d
Only in pintos/examples/lib/user: debug.o
Only in pintos/examples/lib/user: entry.d
Only in pintos/examples/lib/user: entry.o
Only in pintos/examples/lib/user: syscall.d
Only in pintos/examples/lib/user: syscall.o
Only in pintos/examples: libc.a
Only in pintos/examples: lineup
Only in pintos/examples: lineup.d
Only in pintos/examples: lineup.o
Only in pintos/examples: longrun
Only in pintos/examples: longrun.d
Only in pintos/examples: longrun.o
Only in pintos/examples: ls
Only in pintos/examples: ls.d
Only in pintos/examples: ls.o
Only in pintos/examples: matmult
Only in pintos/examples: matmult.d
Only in pintos/examples: matmult.o
Only in pintos/examples: mcat
Only in pintos/examples: mcat.d
Only in pintos/examples: mcat.o
Only in pintos/examples: mcp
Only in pintos/examples: mcp.d
Only in pintos/examples: mcp.o
Only in pintos/examples: mkdir
Only in pintos/examples: mkdir.d
Only in pintos/examples: mkdir.o
Only in pintos/examples: parent
Only in pintos/examples: parent.d
Only in pintos/examples: parent.o
Only in pintos/examples: pfs
Only in pintos/examples: pfs.d
Only in pintos/examples: pfs.o
Only in pintos/examples: pfs_reader
Only in pintos/examples: pfs_reader.d
Only in pintos/examples: pfs_reader.o
Only in pintos/examples: pfs_writer
Only in pintos/examples: pfs_writer.d
Only in pintos/examples: pfs_writer.o
Only in pintos/examples: pwd
Only in pintos/examples: pwd.d
Only in pintos/examples: pwd.o
Only in pintos/examples: recursor
Only in pintos/examples: recursor.d
Only in pintos/examples: recursor.o
Only in pintos/examples: rm
Only in pintos/examples: rm.d
Only in pintos/examples: rm.o
Only in pintos/examples: shell
Only in pintos/examples: shell.c~
Only in pintos/examples: shell.d
Only in pintos/examples: shell.o
Only in pintos/examples: sumargv
Only in pintos/examples: sumargv.d
Only in pintos/examples: sumargv.o
Only in pintos: jesve148-ricwi102_lab-1.diff
diff -wur pintos-linux/lib/string.c pintos/lib/string.c
--- pintos-linux/lib/string.c	2015-09-24 19:18:48.000164000 +0200
+++ pintos/lib/string.c	2016-03-01 10:21:10.002764000 +0100
@@ -236,6 +236,8 @@
 {
   char *token;
   
+	
+  
   ASSERT (delimiters != NULL);
   ASSERT (save_ptr != NULL);
 
@@ -262,6 +264,8 @@
 
   /* Skip any non-DELIMITERS up to the end of the string. */
   token = s;
+
+	
   while (strchr (delimiters, *s) == NULL)
     s++;
   if (*s != '\0') 
Only in pintos/lib: string.c~
Only in pintos/lib/user: syscall.c~
Only in pintos: ricwi102-jesve148_lab-1.diff
Only in pintos: ricwi102-jesve148_lab-2.diff
Only in pintos: ricwi102-jesve148_lab-3.diff
Only in pintos-linux: .svn
Only in pintos/threads: build
diff -wur pintos-linux/threads/thread.c pintos/threads/thread.c
--- pintos-linux/threads/thread.c	2015-09-24 19:18:56.001952000 +0200
+++ pintos/threads/thread.c	2016-03-01 19:12:52.000448000 +0100
@@ -11,6 +11,7 @@
 #include "threads/switch.h"
 #include "threads/synch.h"
 #include "threads/vaddr.h"
+#include "threads/malloc.h"
 #ifdef USERPROG
 #include "userprog/process.h"
 #endif
@@ -67,6 +68,64 @@
 void schedule_tail (struct thread *prev);
 static tid_t allocate_tid (void);
 
+
+
+
+
+
+
+/* Reduces the ref_count of all the given threads 
+	 children and removes them from its list */
+void parent_exit(struct thread *t){	
+	struct list_elem* e = list_begin(&t->cs_list); 	
+
+	while(e != list_end(&t->cs_list)){
+		struct child_status* cs = list_entry(e, struct child_status, elem);	
+
+		e = list_remove(e);
+		reduce_ref_count(cs);		
+	}
+}
+
+
+/* Reduces the refcount by one, which in turn either frees the allocated 
+	 child_status or uses sema_up to unblock the parent_thread from waiting.
+	 (Will sema_up if the parent exits first aswell, 
+	 but that does not change the intended functionality) */
+void reduce_ref_count(struct child_status* cs){
+	if (cs != NULL){		
+		lock_acquire(&cs->l);
+		cs->ref_count--;
+		lock_release(&cs->l);	
+		if (cs->ref_count == 0){
+			free(cs);
+		}else if (cs->ref_count == 1){
+			sema_up(&cs->s);
+		}
+	}
+}
+
+/* Initiates the child_status */
+void cs_init(struct child_status* cs, tid_t tid){
+	sema_init(&cs->s, 0);
+	lock_init(&cs->l);
+	cs->ref_count = 2;
+  cs->c_tid = tid;
+	cs->exit_status = -1;
+}
+
+/* Gets the exit-value if the child has exited.
+	 Othewise it wates for the child to exit before grabbing it */
+int get_exit_value(struct child_status* cs){
+	if (cs->ref_count > 1){	sema_down(&cs->s); }
+	return cs->exit_status;
+}
+
+
+
+
+
+
 /* Initializes the threading system by transforming the code
    that's currently running into a thread.  This can't work in
    general and it is possible in this case only because loader.S
@@ -176,7 +235,13 @@
 
   /* Initialize thread. */
   init_thread (t, name, priority);
-  tid = t->tid = allocate_tid ();
+  tid = allocate_tid ();
+	t->tid = tid;
+	
+	/* Initialize child_status and allocates it*/
+	struct child_status* cs = (struct child_status*)malloc(sizeof(struct child_status));
+	cs_init(cs, tid);
+	t->cs = cs;
 
   /* Stack frame for kernel_thread(). */
   kf = alloc_frame (t, sizeof *kf);
@@ -192,9 +257,19 @@
   sf = alloc_frame (t, sizeof *sf);
   sf->eip = switch_entry;
 
+ 
+		
+	/* Adds child_status to the list if the thread could be created */ // Changed from original
+	if (tid != -1){
+		list_push_back(&thread_current()->cs_list, &cs->elem);		
+	} else {
+		free(cs);
+	}
+
   /* Add to run queue. */
   thread_unblock (t);
 
+
   return tid;
 }
 
@@ -278,6 +353,22 @@
 
 #ifdef USERPROG
   process_exit ();
+	
+
+  unsigned int i;
+  struct thread *t = thread_current();
+  for (i = 0; i < 128; ++i){
+    if (t->fileArray[i] != NULL){
+      file_close(t->fileArray[i]);
+      t->fileArray[i] = NULL;
+    }
+  }	
+
+	parent_exit(t);
+	reduce_ref_count(t->cs);
+	t->cs = NULL;
+	
+
 #endif
 
   /* Just set our status to dying and schedule another process.
@@ -436,6 +527,16 @@
   t->stack = (uint8_t *) t + PGSIZE;
   t->priority = priority;
   t->magic = THREAD_MAGIC;
+
+
+  #ifdef USERPROG
+		unsigned int i;
+		for (i = 0; i < 128; ++i){
+			t->fileArray[i] = NULL;
+	 	}
+		list_init(&t->cs_list);	
+  #endif
+		t->cs = NULL;
 }
 
 /* Allocates a SIZE-byte frame at the top of thread T's stack and
@@ -497,6 +598,7 @@
 #ifdef USERPROG
   /* Activate the new address space. */
   process_activate ();
+   
 #endif
 
   /* If the thread we switched from is dying, destroy its struct
@@ -551,3 +653,12 @@
 /* Offset of `stack' member within `struct thread'.
    Used by switch.S, which can't figure it out on its own. */
 uint32_t thread_stack_ofs = offsetof (struct thread, stack);
+
+
+
+bool
+thread_less_func(struct list_elem *a, struct list_elem *b, void *aux) {
+  return list_entry(a,struct thread,elem)->ticks_when_wakeup <
+         list_entry(b,struct thread,elem)->ticks_when_wakeup;
+
+}
Only in pintos/threads: thread.c~
diff -wur pintos-linux/threads/thread.h pintos/threads/thread.h
--- pintos-linux/threads/thread.h	2015-09-24 19:18:56.002076000 +0200
+++ pintos/threads/thread.h	2016-02-26 14:34:11.000000000 +0100
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -74,6 +75,39 @@
    the `magic' member of the running thread's `struct thread' is
    set to THREAD_MAGIC.  Stack overflow will normally change this
    value, triggering the assertion. */
+
+
+
+/*	
+		Child Status and its functions
+
+
+*/
+
+struct child_status
+	{
+		struct list_elem elem;
+		struct semaphore s;
+		struct lock l;
+
+		int c_tid;		
+
+		int exit_status;		
+		int ref_count;		
+	};
+
+void parent_exit(struct thread *t);
+void reduce_ref_count(struct child_status* cs);
+void cs_init(struct child_status* cs, tid_t tid);
+int get_exit_value(struct child_status* cs);
+
+//---------------
+
+
+
+
+
+
 /* The `elem' member has a dual purpose.  It can be an element in
    the run queue (thread.c), or it can be an element in a
    semaphore wait list (synch.c).  It can be used these two ways
@@ -89,12 +123,22 @@
     uint8_t *stack;                     /* Saved stack pointer. */
     int priority;                       /* Priority. */
 
+    uint64_t ticks_when_wakeup;               /* Number of ticks the thread will sleep in. */
+
     /* Shared between thread.c and synch.c. */
     struct list_elem elem;              /* List element. */
 
+		/* List of Children */
+	 	struct list cs_list;
+
+		/* Child_status */
+		struct child_status* cs;
+
 #ifdef USERPROG
     /* Owned by userprog/process.c. */
     uint32_t *pagedir;                  /* Page directory. */
+    struct file *fileArray[128];
+    
 #endif
 
     /* Owned by thread.c. */
@@ -122,6 +166,7 @@
 tid_t thread_tid (void);
 const char *thread_name (void);
 
+
 void thread_exit (void) NO_RETURN;
 void thread_yield (void);
 
@@ -132,5 +177,13 @@
 void thread_set_nice (int);
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
+bool thread_less_func(struct list_elem *a, struct list_elem *b, void *aux);
+
+
+
+
+
+
+
 
 #endif /* threads/thread.h */
Only in pintos/threads: thread.h~
Only in pintos/userprog: bochsrc.txt
Only in pintos/userprog: build
Only in pintos/userprog: pagedir.c~
diff -wur pintos-linux/userprog/process.c pintos/userprog/process.c
--- pintos-linux/userprog/process.c	2015-09-24 19:18:49.002029000 +0200
+++ pintos/userprog/process.c	2016-03-01 19:12:53.001780000 +0100
@@ -17,54 +17,173 @@
 #include "threads/palloc.h"
 #include "threads/thread.h"
 #include "threads/vaddr.h"
+#include "threads/malloc.h"
 
 static thread_func start_process NO_RETURN;
+
 static bool load (const char *cmdline, void (**eip) (void), void **esp);
 
+
+
+/* Initiates the help_struct */
+void help_sct_init(struct help_struct* h_sct){
+	sema_init(&h_sct->s, 0);
+	h_sct->file_name = h_sct->argv[0];
+	h_sct->success = false;
+}
+
+/* Splits the string to upto 32 arguments and puts the arguments and 
+	 the amount of arguments into the help_struct */
+void
+split_string(char* str, struct help_struct *help_sct){	
+	char* str_copy = malloc(sizeof(char) * (strlen(str) + 1));
+	strlcpy (str_copy, str, PGSIZE);
+
+	const char delim[] = " ";					 // Splits strings on " "
+	char *token, *save_ptr;
+	int8_t i = 0;
+
+	for (token = strtok_r (str_copy, delim, &save_ptr); 
+			token != NULL; token = strtok_r(NULL, delim, &save_ptr))
+	{		
+  	help_sct->argv[i] = malloc(sizeof(char) * (strlen(token) + 1));
+  	strlcpy (help_sct->argv[i], token, PGSIZE);
+		++i;
+		if(i == 32) break;							 // max 32 args
+	}
+	free(str_copy);
+	help_sct->argc = i;
+}
+
+
+// Initiates the stack with the arguments given (argv = arguments, argc = amount of arguments)
+void stack_init(char* argv[32], int8_t argc, void **esp){
+  int8_t i = argc;
+	int8_t offset = 0;
+	char *stackpointer = ((char*)*esp);
+	//printf("%X: PHYS_BASE \n",stackpointer);	
+	//PASSS
+	
+	
+  // Writing argument values 
+	while(i > 0){
+		i--;
+		char *arg = argv[i];
+		int8_t size = strlen(arg) + 1;
+		stackpointer = stackpointer - size;
+		strlcpy(stackpointer,arg,size);	
+		//printf("%X: %s (arg %d value) \n",stackpointer,arg,i);
+		free(argv[i]);
+		argv[i] = stackpointer;
+		offset = (offset + size)%4;
+	}
+	// Writing NULL sentinel
+	while(offset != 0){
+		stackpointer--;
+		*stackpointer = NULL;
+		offset = (offset + 1)%4;
+		//printf("%X: %s (sentinel) \n",stackpointer,*stackpointer);
+	}
+	// Writing argv[argc] (= 0)
+	stackpointer = stackpointer - 4;
+	*stackpointer = NULL;
+	//printf("%X: %s (arg %d adress) \n",stackpointer,*stackpointer, argc);
+	
+	// Writing argument adresses
+	i = argc;
+	while(i > 0){
+		i--;
+		char *adress = argv[i];
+		stackpointer = stackpointer - 4;
+		*((char**)stackpointer) = adress;	
+		//printf("%X: %X (arg %d adress) \n",stackpointer,adress,i);	
+	}
+
+	// Writing argv
+	stackpointer = stackpointer - 4;
+	*((char**)stackpointer) = stackpointer + 4;
+	//printf("%X: %X (argv) \n",stackpointer,stackpointer + 4);	
+
+	// Writing argc
+	stackpointer = stackpointer - 4;
+	*stackpointer = argc;
+	//printf("%X: %d (argc) \n",stackpointer,argc);	
+
+	// Writing a NULL return adress
+	stackpointer = stackpointer - 4;
+	*stackpointer = NULL;
+	//printf("%X: %s (return adress) \n",stackpointer,*stackpointer);
+	
+	*esp = stackpointer;
+	//hex_dump(12,stackpointer,64,true);
+}
+
+
 /* Starts a new thread running a user program loaded from
    FILENAME.  The new thread may be scheduled (and may even exit)
-   before process_execute() returns.  Returns the new process's
-   thread id, or TID_ERROR if the thread cannot be created. */
+   before process_execute() returns.  Returns the new process's thread id 
+	 (or TID_ERROR if the thread cannot be created). */
+
 tid_t
 process_execute (const char *file_name) 
 {
-  char *fn_copy;
+  //char *fn_copy;
+
   tid_t tid;
+  struct help_struct *help_sct = (struct help_struct*)malloc(sizeof(struct help_struct));
+  split_string(file_name,help_sct);
 
   /* Make a copy of FILE_NAME.
      Otherwise there's a race between the caller and load(). */
-  fn_copy = palloc_get_page (0);
+  /*fn_copy = palloc_get_page (0);
   if (fn_copy == NULL)
     return TID_ERROR;
-  strlcpy (fn_copy, file_name, PGSIZE);
+  strlcpy (fn_copy, help_sct->argv[0], PGSIZE);
+  */
+
+	help_sct_init(help_sct);
 
   /* Create a new thread to execute FILE_NAME. */
-  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
-  if (tid == TID_ERROR)
-    palloc_free_page (fn_copy); 
+  tid = thread_create (help_sct->argv[0], PRI_DEFAULT, start_process, help_sct);
+	
+  sema_down(&help_sct->s);
+
+  if (/*tid == TID_ERROR ||*/ !help_sct->success){
+    //palloc_free_page (fn_copy);
+		tid = TID_ERROR;
+	}
+	free(help_sct);
   return tid;
 }
 
+
 /* A thread function that loads a user process and starts it
    running. */
 static void
-start_process (void *file_name_)
+start_process (void* aux)
 {
-  char *file_name = file_name_;
+  struct help_struct *help_sct = (struct help_struct*)aux;
+  char *file_name = help_sct->file_name;
   struct intr_frame if_;
   bool success;
-
   /* Initialize interrupt frame and load executable. */
+
   memset (&if_, 0, sizeof if_);
   if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
   if_.cs = SEL_UCSEG;
   if_.eflags = FLAG_IF | FLAG_MBS;
   success = load (file_name, &if_.eip, &if_.esp);
+	if(success) stack_init(help_sct->argv,help_sct->argc,&if_.esp); // Initializes stack on success
+	//free_argv_pages(help_sct);
+
+  help_sct->success = success;
+	
+  sema_up(&help_sct->s);
 
   /* If load failed, quit. */
-  palloc_free_page (file_name);
-  if (!success) 
+  if (!success) {
     thread_exit ();
+	}
 
   /* Start the user process by simulating a return from an
      interrupt, implemented by intr_exit (in
@@ -81,14 +200,25 @@
    exception), returns -1.  If TID is invalid or if it was not a
    child of the calling process, or if process_wait() has already
    been successfully called for the given TID, returns -1
-   immediately, without waiting.
-
-   This function will be implemented in problem 2-2.  For now, it
-   does nothing. */
+   immediately, without waiting.*/
 int
-process_wait (tid_t child_tid UNUSED) 
+process_wait (tid_t child_tid) 
 {
-  return -1;
+	struct thread* t = thread_current();
+	struct list_elem* e = list_begin(&t->cs_list);
+	int exit_value = -1; 					// Default exit value if the child id cannot be found
+
+	for (e = list_begin(&t->cs_list); e != list_end(&t->cs_list); e = 
+		list_next(e)){
+			struct child_status* cs = list_entry(e, struct child_status, elem);
+			if (cs->c_tid == child_tid){ // Stops the loop if it finds the given child id
+				list_remove(e);
+				exit_value = get_exit_value(cs);
+				reduce_ref_count(cs);
+				break;
+			}
+	}
+  return exit_value;
 }
 
 /* Free the current process's resources. */
@@ -229,7 +359,7 @@
    /* Uncomment the following line to print some debug
      information. This will be useful when you debug the program
      stack.*/
-/*#define STACK_DEBUG*/
+//#define STACK_DEBUG*/
 
 #ifdef STACK_DEBUG
   printf("*esp is %p\nstack contents:\n", *esp);
Only in pintos/userprog: process.c~
diff -wur pintos-linux/userprog/process.h pintos/userprog/process.h
--- pintos-linux/userprog/process.h	2015-09-24 19:18:49.002544000 +0200
+++ pintos/userprog/process.h	2016-02-26 14:34:11.000000000 +0100
@@ -8,4 +8,16 @@
 void process_exit (void);
 void process_activate (void);
 
+
+struct help_struct{
+	struct semaphore s;
+	char* file_name;
+	bool success;
+  char* argv[32];
+  int8_t argc;
+};
+
+void help_sct_init(struct help_struct* h_sct);
+
+
 #endif /* userprog/process.h */
Only in pintos/userprog: process.h~
diff -wur pintos-linux/userprog/syscall.c pintos/userprog/syscall.c
--- pintos-linux/userprog/syscall.c	2015-09-24 19:18:49.001541000 +0200
+++ pintos/userprog/syscall.c	2016-03-01 19:22:43.000148000 +0100
@@ -3,8 +3,20 @@
 #include <syscall-nr.h>
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "userprog/process.h"
+#include "filesys/file.h"
+#include "filesys/filesys.h"
+#include "threads/vaddr.h"
 
 static void syscall_handler (struct intr_frame *);
+int addFile(struct file *f);
+void removeFile(int fd);
+struct file* fdOpen(int fd);
+bool valid_ptr(void* ptr);
+bool check_mult_ptr(void* ptr, int args);
+bool valid_buffer(void* ptr, size_t amount);
+bool valid_str(char* str);
+
 
 void
 syscall_init (void) 
@@ -15,6 +27,220 @@
 static void
 syscall_handler (struct intr_frame *f UNUSED) 
 {
-  printf ("system call!\n");
+  int *p = f->esp;
+  const void *buffer;
+	if (valid_ptr(p)){		
+		size_t size;
+		unsigned int i;
+		switch(*p){
+		case SYS_HALT:{
+		    power_off();
+		    break;	}
+		case SYS_CREATE:{
+				if (check_mult_ptr(p, 2) && valid_str((char*)*(p + 1)) ){
+				  const char *filename = (const char*)(*(p + 1));				
+				  size = *(p + 2);
+				  if(filename != NULL && size >= 0){
+				    f->eax = filesys_create(filename,size);
+				  }else{					
+				    f->eax = false;
+						sys_exit(-1);					
+				  }
+				}
+		    break; }
+		case SYS_OPEN:{
+				if (check_mult_ptr(p, 1) && valid_str((char*)*(p + 1)) ){
+					const char *fileToOpen = (const char*)*(p + 1);     
+				  struct file* openFile = (struct file*)filesys_open(fileToOpen);
+				  if (openFile != NULL){
+				    f->eax = addFile(openFile);
+				  }else{        
+				    f->eax = -1;
+				  }
+				}
+		    break; }
+		case SYS_CLOSE:{
+				if (check_mult_ptr(p, 1)){
+					int fileCloseDescriptor = *(p + 1);
+				  file_close(fdOpen(fileCloseDescriptor));
+				  removeFile(fileCloseDescriptor);
+				}
+		    break; }
+		case SYS_READ:{
+				if (check_mult_ptr(p, 3) && valid_buffer(*(p + 2), (size_t)*(p + 3))){				
+				  int fileReadDescriptor = *(p + 1);      
+				  buffer = (const void*)(*(p + 2));
+					size = *(p + 3);		
+				  
+				  if(fileReadDescriptor == STDIN_FILENO){
+						for(i = 0; i < size; i++){
+							if (valid_ptr((char*)buffer + i)){
+								*((char*)buffer + i) = input_getc();
+							}								
+						}
+						f->eax = size;
+					}else if(fileReadDescriptor == STDOUT_FILENO){
+						f->eax = -1;
+					}else{ 
+				    struct file* openFile = fdOpen(fileReadDescriptor);  
+				    if (openFile != NULL){
+				      f->eax = file_read(openFile,buffer,size);
+				    } else {
+				      f->eax = -1;
+				    } 
+				  }
+				}
+		    break; }
+		case SYS_WRITE:{
+				if (check_mult_ptr(p, 3) && valid_buffer(*(p + 2), (size_t)*(p + 3)) ){
+				  int fileWriteDescriptor = *(p + 1);
+				  buffer = (const void*)(*(p + 2));		
+				  size = *(p + 3);
+
+				  if(fileWriteDescriptor == STDOUT_FILENO){
+						static const size_t chunk_size_max = 200;
+						for (i = 0; i <= (size/chunk_size_max); ++i){
+							size_t chunk_size = (size / chunk_size_max) > i ? chunk_size_max : (size % chunk_size_max);
+				   		putbuf((buffer + i*chunk_size_max), chunk_size);          
+						}	
+						f->eax = size;
+				  }else if(fileWriteDescriptor == STDIN_FILENO){
+						f->eax = -1;
+					}else{   
+				 		struct file* openFile = fdOpen(fileWriteDescriptor);        
+						if (openFile != NULL){
+				    	f->eax = file_write(openFile,buffer,size);
+				  	} else {
+				  		f->eax = -1;
+				  	}
+					}
+		    }
+		    break; }
+		case SYS_EXIT:{
+				if (check_mult_ptr(p, 1)){
+					int exit_status = (int)(*(p + 1));
+					f->eax = exit_status;
+					sys_exit(exit_status);
+				}
+		    break; }
+		case SYS_EXEC:{				
+				if (check_mult_ptr(p, 1) && valid_str((char*)*(p + 1)) ){				
+					char *filename = (const char*)(*(p + 1));
+					int pid = process_execute(filename);
+					if (pid == TID_ERROR) { 
+						f->eax =  -1;					
+					}
+					else f->eax = pid;		
+				}		
+				break; }
+		case SYS_WAIT:{
+				if (check_mult_ptr(p, 1)){
+					int exit_value = process_wait((tid_t) (*(p + 1)));
+					f->eax = exit_value;
+				}
+				break; }
+		default:{
+		    printf ("default system call! SYS_NR: ");
+		    printf ("%d \n",*p);
+		    break; }
+		}
+  }
+}
+
+
+		/* Checks if a pointer is valid for that thread and exits if it is not.
+		 	 Valid -> Smaller than PHYS_BASE and within one of the threads pages.  
+		 	 Checks if the pointer is atleast on an adress 4 smaller than phys-base, 
+			 since a pointer is always 4 bytes.*/
+		bool valid_ptr(void* ptr){ 			
+			if (ptr >= (PHYS_BASE - 4) || (pagedir_get_page(thread_current()->pagedir, ptr + 3) == NULL)){				
+				sys_exit(-1);
+				return false;
+			}		
+			return true;
+		}
+	
+
+		/* Checks multiple pointers with (valid_ptr(void' ptr)) starting from the
+			 pointer after th given pointer and checks (args) pointers afterwrds. */
+		bool check_mult_ptr(void* ptr, int args){
+			uint8_t i;
+			for (i = 1; i <= args; ++i){
+				if (!valid_ptr(ptr + i)) {return false;}
+			}
+			return true;
+		}
+
+		bool valid_buffer(void* ptr, size_t amount){		
+			size_t i;
+			for (i = 0; i < amount; ++i){
+				if (!valid_ptr((ptr + i) )) {return false;}
+			}
+			return true;
+		}
+
+		bool valid_str(char* str){
+			int i  = -1;
+			do {
+				if (!valid_ptr( str +  ++i ) ) { return false; }
+			} while ( *(str + i) != '\0' );
+			return true;
+		}
+
+
+		/* exits and closes the thread with the given exit_status */
+		void sys_exit(int exit_status){
+			printf("%s: exit(%d)\n", thread_current()->name, exit_status);		
+			thread_current()->cs->exit_status = exit_status;
   thread_exit ();
 }
+
+		/* Adds a file to the file array if it isn't full */
+    int addFile(struct file *f){
+      struct thread *t = thread_current();
+      unsigned int i;
+      for (i = 0; i < 128; ++i){
+        if(t->fileArray[i] == NULL){
+          t->fileArray[i] = f;
+          return i+2;
+        }
+      }
+		  file_close(f);
+        return -1;
+    }
+
+		/* Sets the position of the file descriptor to NULL.
+			 File has to have already been closed */
+    void removeFile(int fd){
+			if (fd >= 2 && fd < 130){
+      	struct thread *t = thread_current();
+      	t->fileArray[fd - 2] = NULL;
+			}
+    }
+
+
+		/* Opens a file from the filearray with the given file descriptor.
+			 returns NULL if the (fd) is out of bounds or there is no file with that (fd) */
+    struct file* fdOpen(int fd){
+      if (fd >= 2 && fd < 130){
+        struct thread *t = thread_current();				
+        return t->fileArray[fd - 2];
+      } else {
+			return NULL;
+      }
+    }
+   
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Only in pintos/userprog: syscall.c~
Only in pintos/utils: qemu
Only in pintos/utils: setitimer-helper
Only in pintos/utils: setitimer-helper.o
Only in pintos/utils: squish-pty
Only in pintos/utils: squish-pty.o
Only in pintos/utils: squish-unix
Only in pintos/utils: squish-unix.o
