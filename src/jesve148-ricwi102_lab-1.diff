Only in pintos/devices: disk.c~
diff -wur pintos-linux/devices/timer.c pintos/devices/timer.c
--- pintos-linux/devices/timer.c	2015-09-24 19:18:54.001764000 +0200
+++ pintos/devices/timer.c	2016-02-18 11:38:58.000182000 +0100
@@ -35,6 +35,8 @@
 void
 timer_init (void) 
 {
+  list_init(&sleep_list);
+
   /* 8254 input frequency divided by TIMER_FREQ, rounded to
      nearest. */
   uint16_t count = (1193180 + TIMER_FREQ / 2) / TIMER_FREQ;
@@ -96,11 +98,34 @@
 void
 timer_sleep (int64_t ticks) 
 {
-  int64_t start = timer_ticks ();
-
   ASSERT (intr_get_level () == INTR_ON);
+  if(ticks > 0){
+
+    enum intr_level old_level;
+    old_level = intr_disable();
+ 
+    thread_current()->ticks_when_wakeup = timer_ticks() + ticks;
+
+    list_insert_ordered(&sleep_list,&thread_current()->elem, 
+    thread_less_func,NULL);
+
+    thread_block();
+// Prints the wake-up values in the list (to check if it is sorted)
+/*
+    struct list_elem* e;
+    for (e = list_begin(&sleep_list); e != list_end(&sleep_list); e = list_next(e)){
+      struct thread *p_thread = list_entry(e, struct thread, elem);
+      printf("%i", p_thread->ticks_when_wakeup);
+      printf("\n");
+    }
+    printf("%s", "Next loop \n");
+*/
+    intr_set_level(old_level);
+  }
+
+  /*int64_t start = timer_ticks ();
   while (timer_elapsed (start) < ticks) 
-    thread_yield ();
+    thread_yield ();*/
 }
 
 /* Suspends execution for approximately MS milliseconds. */
@@ -136,7 +161,25 @@
 timer_interrupt (struct intr_frame *args UNUSED)
 {
   ticks++;
-  thread_tick ();
+  thread_tick (); // i think this should be at the bottom, (Richard)
+
+  uint8_t i = 0;
+  struct list_elem* e = list_begin(&sleep_list);
+  while(e != list_end(&sleep_list)){
+    struct thread *current_thread = list_entry(e, struct thread, elem);
+    if(current_thread->ticks_when_wakeup <= timer_ticks()){
+      i++;
+      e = list_next(e);
+    }else{ 
+      break;
+    }
+  }
+  for(i; i > 0;--i){
+    e = list_pop_front(&sleep_list);
+    struct thread* t =  list_entry(e,struct thread,elem);
+    thread_unblock(t);
+  }
+
 }
 
 /* Returns true if LOOPS iterations waits for more than one timer
Only in pintos/devices: timer.c~
diff -wur pintos-linux/devices/timer.h pintos/devices/timer.h
--- pintos-linux/devices/timer.h	2015-09-24 19:18:54.002090000 +0200
+++ pintos/devices/timer.h	2016-02-09 09:18:03.000044000 +0100
@@ -7,6 +7,8 @@
 /* Number of timer interrupts per second. */
 #define TIMER_FREQ 100
 
+struct list sleep_list;
+
 void timer_init (void);
 void timer_calibrate (void);
 
Only in pintos/devices: timer.h~
Only in pintos/examples: a.out
Only in pintos/examples: bubsort
Only in pintos/examples: bubsort.d
Only in pintos/examples: bubsort.o
Only in pintos/examples: cat
Only in pintos/examples: cat.d
Only in pintos/examples: cat.o
Only in pintos/examples: child
Only in pintos/examples: child.d
Only in pintos/examples: child.o
Only in pintos/examples: cmp
Only in pintos/examples: cmp.d
Only in pintos/examples: cmp.o
Only in pintos/examples: cp
Only in pintos/examples: cp.d
Only in pintos/examples: cp.o
Only in pintos/examples: create-bad
Only in pintos/examples: create-bad.d
Only in pintos/examples: create-bad.o
Only in pintos/examples: dummy
Only in pintos/examples: dummy.d
Only in pintos/examples: dummy.o
Only in pintos/examples: echo
Only in pintos/examples: echo.d
Only in pintos/examples: echo.o
Only in pintos/examples: halt
Only in pintos/examples: halt.d
Only in pintos/examples: halt.o
Only in pintos/examples: hex-dump
Only in pintos/examples: hex-dump.d
Only in pintos/examples: hex-dump.o
Only in pintos/examples: insult
Only in pintos/examples: insult.d
Only in pintos/examples: insult.o
Only in pintos/examples: lab1test
diff -wur pintos-linux/examples/lab1test.c pintos/examples/lab1test.c
--- pintos-linux/examples/lab1test.c	2015-09-24 19:18:52.001119000 +0200
+++ pintos/examples/lab1test.c	2016-02-23 15:14:26.001909000 +0100
@@ -58,6 +58,8 @@
 	
   write(STDOUT_FILENO, test6, strlen(test6));
   num_bytes_read = read(STDIN_FILENO, sbuf, 10);
+  file[2] = open("test2");
+  write(file[2],sbuf,10);
   if(num_bytes_read != 10){
     printf("Did not read 10 characters from the console.\n");
     halt();
@@ -103,5 +105,5 @@
   }
 
   printf("Test passed\n");
-  halt();
+  exit(0);
 }
Only in pintos/examples: lab1test.c~
Only in pintos/examples: lab1test.d
Only in pintos/examples: lab1test.o
Only in pintos/examples: lab2test
Only in pintos/examples: lab2test.d
Only in pintos/examples: lab2test.o
Only in pintos/examples/lib: arithmetic.d
Only in pintos/examples/lib: arithmetic.o
Only in pintos/examples/lib: debug.d
Only in pintos/examples/lib: debug.o
Only in pintos/examples/lib: random.d
Only in pintos/examples/lib: random.o
Only in pintos/examples/lib: stdio.d
Only in pintos/examples/lib: stdio.o
Only in pintos/examples/lib: stdlib.d
Only in pintos/examples/lib: stdlib.o
Only in pintos/examples/lib: string.d
Only in pintos/examples/lib: string.o
Only in pintos/examples/lib/user: console.d
Only in pintos/examples/lib/user: console.o
Only in pintos/examples/lib/user: debug.d
Only in pintos/examples/lib/user: debug.o
Only in pintos/examples/lib/user: entry.d
Only in pintos/examples/lib/user: entry.o
Only in pintos/examples/lib/user: syscall.d
Only in pintos/examples/lib/user: syscall.o
Only in pintos/examples: libc.a
Only in pintos/examples: lineup
Only in pintos/examples: lineup.d
Only in pintos/examples: lineup.o
Only in pintos/examples: longrun
Only in pintos/examples: longrun.d
Only in pintos/examples: longrun.o
Only in pintos/examples: ls
Only in pintos/examples: ls.d
Only in pintos/examples: ls.o
Only in pintos/examples: matmult
Only in pintos/examples: matmult.d
Only in pintos/examples: matmult.o
Only in pintos/examples: mcat
Only in pintos/examples: mcat.d
Only in pintos/examples: mcat.o
Only in pintos/examples: mcp
Only in pintos/examples: mcp.d
Only in pintos/examples: mcp.o
Only in pintos/examples: mkdir
Only in pintos/examples: mkdir.d
Only in pintos/examples: mkdir.o
Only in pintos/examples: parent
Only in pintos/examples: parent.d
Only in pintos/examples: parent.o
Only in pintos/examples: pfs
Only in pintos/examples: pfs.d
Only in pintos/examples: pfs.o
Only in pintos/examples: pfs_reader
Only in pintos/examples: pfs_reader.d
Only in pintos/examples: pfs_reader.o
Only in pintos/examples: pfs_writer
Only in pintos/examples: pfs_writer.d
Only in pintos/examples: pfs_writer.o
Only in pintos/examples: pwd
Only in pintos/examples: pwd.d
Only in pintos/examples: pwd.o
Only in pintos/examples: recursor
Only in pintos/examples: recursor.d
Only in pintos/examples: recursor.o
Only in pintos/examples: rm
Only in pintos/examples: rm.d
Only in pintos/examples: rm.o
Only in pintos/examples: shell
diff -wur pintos-linux/examples/shell.c pintos/examples/shell.c
--- pintos-linux/examples/shell.c	2015-09-24 19:18:52.000736000 +0200
+++ pintos/examples/shell.c	2016-02-23 15:00:09.000067000 +0100
@@ -18,6 +18,8 @@
       printf ("--");
       read_line (command, sizeof command);
       
+	printf("Test 2 \n");
+      
       /* Execute command. */
       if (!strcmp (command, "exit"))
         break;
@@ -33,6 +35,8 @@
       else
         {
           pid_t pid = exec (command);
+					printf("%i", pid);
+					printf(" : pid \n");
           if (pid != PID_ERROR)
             printf ("\"%s\": exit code %d\n", command, wait (pid));
           else
@@ -51,6 +55,7 @@
 static void
 read_line (char line[], size_t size) 
 {
+	printf("Test 1 \n");
   char *pos = line;
   for (;;)
     {
Only in pintos/examples: shell.c~
Only in pintos/examples: shell.d
Only in pintos/examples: shell.o
Only in pintos/examples: sumargv
Only in pintos/examples: sumargv.d
Only in pintos/examples: sumargv.o
Only in pintos: jesve148-ricwi102_lab-1.diff
Only in pintos: ricwi102-jesve148_lab-1.diff
Only in pintos: ricwi102-jesve148_lab-2.diff
Only in pintos-linux: .svn
Only in pintos/threads: build
diff -wur pintos-linux/threads/thread.c pintos/threads/thread.c
--- pintos-linux/threads/thread.c	2015-09-24 19:18:56.001952000 +0200
+++ pintos/threads/thread.c	2016-02-23 16:05:12.002593000 +0100
@@ -11,6 +11,7 @@
 #include "threads/switch.h"
 #include "threads/synch.h"
 #include "threads/vaddr.h"
+#include "threads/malloc.h"
 #ifdef USERPROG
 #include "userprog/process.h"
 #endif
@@ -67,6 +68,57 @@
 void schedule_tail (struct thread *prev);
 static tid_t allocate_tid (void);
 
+
+
+
+
+
+
+/* Reduces the ref_count of all the given threads 
+	 children and removes them from its list */
+
+void parent_exit(struct thread *t){		
+	struct list_elem* e = list_begin(&t->cs_list); 
+
+	while(e != list_end(&t->cs_list)){
+		struct child_status* cs = list_entry(e, struct child_status, elem);
+
+		reduce_ref_count(cs);
+		e = list_remove(e);		
+	}
+
+}
+
+void reduce_ref_count(struct child_status* cs){
+	if (cs != NULL){		
+		lock_acquire(&cs->l);
+		cs->ref_count--;
+		lock_release(&cs->l);	
+		if (cs->ref_count == 0){
+			free(cs);
+		}else if (cs->ref_count == 1){
+			sema_up(&cs->s);
+		}
+	}
+}
+
+void cs_init(struct child_status* cs, tid_t tid){
+	sema_init(&cs->s, 0);
+	lock_init(&cs->l);
+	cs->ref_count = 2;
+  cs->c_tid = tid;
+}
+
+int get_exit_value(struct child_status* cs){
+	if (cs->ref_count > 1){	sema_down(&cs->s); }
+	return cs->exit_status;
+}
+
+
+
+
+
+
 /* Initializes the threading system by transforming the code
    that's currently running into a thread.  This can't work in
    general and it is possible in this case only because loader.S
@@ -176,7 +228,13 @@
 
   /* Initialize thread. */
   init_thread (t, name, priority);
-  tid = t->tid = allocate_tid ();
+  tid = allocate_tid ();
+	t->tid = tid;
+	
+	/* Initialize child_status */ // Changed from original
+	struct child_status* cs = (struct child_status*)malloc(sizeof(struct child_status));
+	cs_init(cs, tid);
+	t->cs = cs;
 
   /* Stack frame for kernel_thread(). */
   kf = alloc_frame (t, sizeof *kf);
@@ -195,6 +253,14 @@
   /* Add to run queue. */
   thread_unblock (t);
 
+	/* Adds child_status to the list if the thread could be created */ // Changed from original
+	if (tid != -1){
+		printf("CHILD -> LIST \n");
+		list_push_back(&thread_current()->cs_list, &cs->elem);
+	} else {
+		free(cs);
+	}
+
   return tid;
 }
 
@@ -278,6 +344,20 @@
 
 #ifdef USERPROG
   process_exit ();
+
+  unsigned int i;
+  struct thread *t = thread_current();
+  for (i = 0; i < 128; ++i){
+    if (t->fileArray[i] != NULL){
+      file_close(t->fileArray[i]);
+      t->fileArray[i] = NULL;
+    }
+  }	
+
+	parent_exit(t);
+	reduce_ref_count(t->cs);
+	t->cs = NULL;
+
 #endif
 
   /* Just set our status to dying and schedule another process.
@@ -436,6 +516,16 @@
   t->stack = (uint8_t *) t + PGSIZE;
   t->priority = priority;
   t->magic = THREAD_MAGIC;
+
+	// Changes from original
+  #ifdef USERPROG
+		unsigned int i;
+		for (i = 0; i < 128; ++i){
+			t->fileArray[i] = NULL;
+	 	}
+		list_init(&t->cs_list);	
+  #endif
+		t->cs = NULL;
 }
 
 /* Allocates a SIZE-byte frame at the top of thread T's stack and
@@ -497,6 +587,7 @@
 #ifdef USERPROG
   /* Activate the new address space. */
   process_activate ();
+   
 #endif
 
   /* If the thread we switched from is dying, destroy its struct
@@ -551,3 +642,12 @@
 /* Offset of `stack' member within `struct thread'.
    Used by switch.S, which can't figure it out on its own. */
 uint32_t thread_stack_ofs = offsetof (struct thread, stack);
+
+
+
+bool
+thread_less_func(struct list_elem *a, struct list_elem *b, void *aux) {
+  return list_entry(a,struct thread,elem)->ticks_when_wakeup <
+         list_entry(b,struct thread,elem)->ticks_when_wakeup;
+
+}
Only in pintos/threads: thread.c~
diff -wur pintos-linux/threads/thread.h pintos/threads/thread.h
--- pintos-linux/threads/thread.h	2015-09-24 19:18:56.002076000 +0200
+++ pintos/threads/thread.h	2016-02-23 14:47:04.001438000 +0100
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -74,6 +75,39 @@
    the `magic' member of the running thread's `struct thread' is
    set to THREAD_MAGIC.  Stack overflow will normally change this
    value, triggering the assertion. */
+
+
+
+/*	
+		Child Status and its functions
+
+
+*/
+
+struct child_status
+	{
+		struct list_elem elem;
+		struct semaphore s;
+		struct lock l;
+
+		int c_tid;		
+
+		int exit_status;		
+		int ref_count;		
+	};
+
+void parent_exit(struct thread *t);
+void reduce_ref_count(struct child_status* cs);
+void cs_init(struct child_status* cs, tid_t tid);
+int get_exit_value(struct child_status* cs);
+
+//---------------
+
+
+
+
+
+
 /* The `elem' member has a dual purpose.  It can be an element in
    the run queue (thread.c), or it can be an element in a
    semaphore wait list (synch.c).  It can be used these two ways
@@ -89,12 +123,22 @@
     uint8_t *stack;                     /* Saved stack pointer. */
     int priority;                       /* Priority. */
 
+    uint64_t ticks_when_wakeup;               /* Number of ticks the thread will sleep in. */
+
     /* Shared between thread.c and synch.c. */
     struct list_elem elem;              /* List element. */
 
+		/* List of Children */
+	 	struct list cs_list;
+
+		/* Child_status */
+		struct child_status* cs;
+
 #ifdef USERPROG
     /* Owned by userprog/process.c. */
     uint32_t *pagedir;                  /* Page directory. */
+    struct file *fileArray[128];
+    
 #endif
 
     /* Owned by thread.c. */
@@ -132,5 +176,13 @@
 void thread_set_nice (int);
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
+bool thread_less_func(struct list_elem *a, struct list_elem *b, void *aux);
+
+
+
+
+
+
+
 
 #endif /* threads/thread.h */
Only in pintos/threads: thread.h~
Only in pintos/userprog: bochsrc.txt
Only in pintos/userprog: build
diff -wur pintos-linux/userprog/process.c pintos/userprog/process.c
--- pintos-linux/userprog/process.c	2015-09-24 19:18:49.002029000 +0200
+++ pintos/userprog/process.c	2016-02-23 14:47:05.000925000 +0100
@@ -19,12 +19,28 @@
 #include "threads/vaddr.h"
 
 static thread_func start_process NO_RETURN;
+
 static bool load (const char *cmdline, void (**eip) (void), void **esp);
 
+
+
+
+void help_sct_init(struct help_struct* h_sct, char* f_n){
+	sema_init(&h_sct->s, 0);
+	h_sct->file_name = f_n;
+	h_sct->success = false;
+}
+
+
+
+
+
+
 /* Starts a new thread running a user program loaded from
    FILENAME.  The new thread may be scheduled (and may even exit)
-   before process_execute() returns.  Returns the new process's
-   thread id, or TID_ERROR if the thread cannot be created. */
+   before process_execute() returns.  Returns the new process's thread id 
+	 (or TID_ERROR if the thread cannot be created). */
+
 tid_t
 process_execute (const char *file_name) 
 {
@@ -38,19 +54,33 @@
     return TID_ERROR;
   strlcpy (fn_copy, file_name, PGSIZE);
 
+
+  struct help_struct help_sct;
+	help_sct_init(&help_sct, fn_copy);
+
   /* Create a new thread to execute FILE_NAME. */
-  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
-  if (tid == TID_ERROR)
+  tid = thread_create (file_name, PRI_DEFAULT, start_process, &help_sct);
+	
+  sema_down(&help_sct.s);
+
+	printf("%i", help_sct.success);
+	printf(" : help_sct success  \n");
+
+  if (tid == TID_ERROR || !help_sct.success){
     palloc_free_page (fn_copy); 
+		return TID_ERROR;
+	}
   return tid;
 }
 
+
 /* A thread function that loads a user process and starts it
    running. */
 static void
-start_process (void *file_name_)
+start_process (void* aux)
 {
-  char *file_name = file_name_;
+  struct help_struct *help_sct = (struct help_struct*)aux;
+  char *file_name = help_sct->file_name;
   struct intr_frame if_;
   bool success;
 
@@ -61,10 +91,15 @@
   if_.eflags = FLAG_IF | FLAG_MBS;
   success = load (file_name, &if_.eip, &if_.esp);
 
+  help_sct->success = success;
+	printf("%i", success);
+	printf(" : success  \n");
+  sema_up(&help_sct->s);
+
   /* If load failed, quit. */
-  palloc_free_page (file_name);
-  if (!success) 
+  if (!success) {
     thread_exit ();
+	}
 
   /* Start the user process by simulating a return from an
      interrupt, implemented by intr_exit (in
@@ -86,9 +121,30 @@
    This function will be implemented in problem 2-2.  For now, it
    does nothing. */
 int
-process_wait (tid_t child_tid UNUSED) 
+process_wait (tid_t child_tid) 
 {
-  return -1;
+	struct thread* t = thread_current();
+	struct list_elem* e = list_begin(&t->cs_list);
+	int exit_value = -1;
+
+
+	printf("%i", child_tid);
+	printf(" : process wait c_tid \n");
+	printf("%i", list_size(&t->cs_list));
+	printf(" : process wait list_size \n");
+
+	for (e = list_begin(&t->cs_list); e != list_end(&t->cs_list); e = list_next(e)){
+			struct child_status* cs = list_entry(e, struct child_status, elem);
+			printf("%i", cs->c_tid);
+			printf(" : CHILD_TID  \n");
+			if (cs->c_tid == child_tid){
+				exit_value = get_exit_value(cs);
+				reduce_ref_count(cs);
+				break;
+			}
+
+	}
+  return exit_value;
 }
 
 /* Free the current process's resources. */
@@ -476,7 +532,7 @@
     {
       success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
       if (success)
-        *esp = PHYS_BASE;
+        *esp = PHYS_BASE - 12;
       else
         palloc_free_page (kpage);
     }
Only in pintos/userprog: process.c~
diff -wur pintos-linux/userprog/process.h pintos/userprog/process.h
--- pintos-linux/userprog/process.h	2015-09-24 19:18:49.002544000 +0200
+++ pintos/userprog/process.h	2016-02-23 14:47:05.001079000 +0100
@@ -8,4 +8,14 @@
 void process_exit (void);
 void process_activate (void);
 
+
+struct help_struct{
+	struct semaphore s;
+	char* file_name; 
+	bool success;
+};
+
+void help_sct_init(struct help_struct* h_sct, char* f_n);
+
+
 #endif /* userprog/process.h */
Only in pintos/userprog: process.h~
diff -wur pintos-linux/userprog/syscall.c pintos/userprog/syscall.c
--- pintos-linux/userprog/syscall.c	2015-09-24 19:18:49.001541000 +0200
+++ pintos/userprog/syscall.c	2016-02-23 16:07:37.000923000 +0100
@@ -3,8 +3,15 @@
 #include <syscall-nr.h>
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "userprog/process.h"
+#include "filesys/file.h"
+#include "filesys/filesys.h"
 
 static void syscall_handler (struct intr_frame *);
+int addFile(struct file *f);
+void removeFile(int fd);
+struct file* fdOpen(int fd);
+
 
 void
 syscall_init (void) 
@@ -15,6 +22,142 @@
 static void
 syscall_handler (struct intr_frame *f UNUSED) 
 {
-  printf ("system call!\n");
+  int *p = f->esp;
+  const void *buffer;
+  size_t size;
+  unsigned int i;
+  switch(*p){
+  case SYS_HALT:
+      power_off();
+      break;
+  case SYS_CREATE:{
+      const char *filename = (const char*)(*(p + 1));
+      size = *(p + 2);
+      if(*filename != NULL){
+        f->eax = filesys_create(filename,size);
+      }else{
+        f->eax = false;
+      }
+      break; }
+  case SYS_OPEN:{
+      const char *fileToOpen = (const char*)*(p + 1);     
+      struct file* openFile = (struct file*)filesys_open(fileToOpen);
+      if (openFile != NULL){
+        f->eax = addFile(openFile);
+      } else {        
+        f->eax = -1;
+      }
+      break; }
+  case SYS_CLOSE:{
+      int fileCloseDescriptor = *(p + 1);
+      file_close(fdOpen(fileCloseDescriptor));
+      removeFile(fileCloseDescriptor);
+      break; }
+  case SYS_READ:{
+      int fileReadDescriptor = *(p + 1);      
+      buffer = (const void*)(*(p + 2));
+      size = *(p + 3);
+      if(fileReadDescriptor == STDIN_FILENO){
+			for(i = 0; i < size; i++){
+	  			*((char*)buffer + i) = input_getc();
+        	}
+        	f->eax = size;
+      }
+      else{ 
+        struct file* openFile = fdOpen(fileReadDescriptor);  
+        if (openFile != NULL){
+          f->eax = file_read(openFile,buffer,size);
+        } else {
+          f->eax = -1;
+        } 
+      }      
+      break; }
+  case SYS_WRITE:{
+      int fileWriteDescriptor = *(p + 1);
+      buffer = (const void*)(*(p + 2));
+      size = *(p + 3);
+      if(fileWriteDescriptor == STDOUT_FILENO){
+			static const size_t chunk_size_max = 200;
+			for (i = 0; i <= (size/chunk_size_max); ++i){
+	  		size_t chunk_size = (size / chunk_size_max) > i ? chunk_size_max : (size % chunk_size_max);
+       	putbuf((buffer + i*chunk_size_max), chunk_size);          
+			}
+			f->eax = size;
+      }else{   
+       	struct file* openFile = fdOpen(fileWriteDescriptor);        
+			if (openFile != NULL){
+        f->eax = file_write(openFile,buffer,size);
+      } else {
+      	f->eax = -1;
+      }
+      }
+      break; }
+  case SYS_EXIT:{
+			int exit_value = (int)(*(p + 1));
+			printf("%s: exit(%d) \n", thread_current()->name, exit_value);
   thread_exit ();
+      //Freed the file-array in thread_exit()      
+			f->eax = exit_value;
+      break; }
+  case SYS_EXEC:{
+			printf("---- EXEC ---- \n");
+      const char *filename = (const char*)(*(p + 1));
+			int pid = process_execute(filename);
+			printf("%i", pid);
+			printf("\n");
+			if (pid == TID_ERROR) { f->eax =  -1; }
+			else f->eax = pid;				
+  		break; }
+  case SYS_WAIT:{
+			int exit_value = process_wait((tid_t) (*(p + 1)));
+			f->eax = exit_value;
+  		break; }
+  default:{
+      printf ("default system call! SYS_NR: ");
+      printf ("%d \n",*p);
+      break; }
+  }
+}
+
+
+    int addFile(struct file *f){
+      struct thread *t = thread_current();
+      unsigned int i;
+      for (i = 0; i < 128; ++i){
+        if(t->fileArray[i] == NULL){
+          t->fileArray[i] = f;
+          return i+2;
+        }
+      }
+		  file_close(f);
+        return -1;
+    }
+
+    void removeFile(int fd){
+      struct thread *t = thread_current();
+      t->fileArray[fd - 2] = NULL;
 }
+
+    struct file* fdOpen(int fd){
+      if (fd >= 2 && fd < 130){
+        struct thread *t = thread_current();				
+        return t->fileArray[fd - 2];
+      } else {
+			return NULL;
+      }
+    }
+   
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Only in pintos/userprog: syscall.c~
Only in pintos/utils: qemu
Only in pintos/utils: setitimer-helper
Only in pintos/utils: setitimer-helper.o
Only in pintos/utils: squish-pty
Only in pintos/utils: squish-pty.o
Only in pintos/utils: squish-unix
Only in pintos/utils: squish-unix.o
